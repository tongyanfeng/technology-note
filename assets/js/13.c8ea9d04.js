(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{660:function(a,t,s){"use strict";s.r(t);var v=s(12),e=Object(v.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h3",{attrs:{id:"_4-1-原始表达式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-原始表达式"}},[a._v("#")]),a._v(" 4.1 原始表达式")]),a._v(" "),s("p",[a._v("表达式分以下几种：直接量、保留字构成的原始表达式、变量")]),a._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 直接量")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1.23")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"hello"')]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("pattern"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 保留字")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token boolean"}},[a._v("true")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token boolean"}},[a._v("false")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("this")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 变量")]),a._v("\ni\nsum\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("undefined")]),a._v("\n")])])]),s("h3",{attrs:{id:"_4-6-对象创建表达式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-6-对象创建表达式"}},[a._v("#")]),a._v(" 4.6 对象创建表达式")]),a._v(" "),s("blockquote",[s("p",[a._v("对象创建表达式创建一个对象并调用一个函数（这个函数称之为构造函数）初始化新的对象的属性。")])]),a._v(" "),s("p",[a._v("对象创建表达式形式是"),s("code",[a._v("new Object()")]),a._v("、"),s("code",[a._v("new Point(2,3)")]),a._v("，如果一个对象创建表达式不需要传入任何参数给构造函数，那么后面的"),s("code",[a._v("()")]),a._v("可以忽略，如"),s("code",[a._v("new Object")]),a._v("、"),s("code",[a._v("new Date")]),a._v("。"),s("br"),a._v(" "),s("strong",[a._v("创建对象的一个过程：")]),s("br"),a._v("\nJavascript 创建一个新的空对象，然后 Javascript 通过传入指定的参数，将会这个新的对象当做 this 的值来调用一个制定的函数。"),s("br"),a._v("\n这个函数可以使用 this 来初始化这个新创建的对象的属性。"),s("br"),a._v("\n那些被当成构造函数的函数不会返回一个值，并且这个新创建并被初始化后的对象，就作为整个对象创建表达式的值。"),s("br"),a._v("\n如果一个构造函数确实返回了一个对象值，那么这个对象就作为整个对象创建表达式的值，而新创建的对象就废弃了。\nps：这里和原有理解有出入，待回看。")]),a._v(" "),s("h3",{attrs:{id:"_4-7-4-运算符的副作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-7-4-运算符的副作用"}},[a._v("#")]),a._v(" 4.7.4 运算符的副作用")]),a._v(" "),s("p",[a._v("副作用")]),a._v(" "),s("h3",{attrs:{id:"_4-7-8-算数表达式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-7-8-算数表达式"}},[a._v("#")]),a._v(" 4.7.8 算数表达式")]),a._v(" "),s("p",[a._v("运算符“取余”"),s("code",[a._v("%")]),a._v("，余数的符号位是跟着第一个操作数保持一致")]),a._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("5")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("%")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),a._v("            "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// => -2.5")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("5")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("%")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("          "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// => 2.5")]),a._v("\n")])])]),s("h3",{attrs:{id:"_4-8-1-运算符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-8-1-运算符"}},[a._v("#")]),a._v(" 4.8.1 “+”运算符")]),a._v(" "),s("p",[a._v("加号的转换规则，有限考虑字符串的连接，如果其中一个操作数是字符串活着转换为字符串的对象，另外一个操作数将会转换为字符串，加法将进行字符串的连接操作。如果两个都不是字符串，将会进行算数加法运算。")]),a._v(" "),s("h3",{attrs:{id:"_4-8-3-位运算符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-8-3-位运算符"}},[a._v("#")]),a._v(" 4.8.3 位运算符")]),a._v(" "),s("blockquote",[s("p",[a._v("位运算符要求它的操作数是整数，这些证书表示为 32 位整型。"),s("br"),a._v("\n移位运算符要求右操作数在0～31位之间，在将其操作数转换为无符号位 32 位整数后，它们将舍弃第 5 位之后的二进制位，以便生成一个位数正确的数字。"),s("br"),a._v("\n需要注意的是，位运算符会将 NaN、Infinity 和 -Infinity 都转换为 0。")])]),a._v(" "),s("p",[s("strong",[a._v("运算规则")])]),a._v(" "),s("ul",[s("li",[a._v("按位与 &："),s("br"),a._v("\n对整型操作数逐位执行布尔与操作，只有两个操作数中相对应的位都是 1，结果中的这一位才是 1。eg: 0x1234 & 0x00FF = 0x0034。\n0x1234 => 0001 0010 0011 0100\n0x00FF => 0000 0000 1111 1111\n=  0000 0000 0011 0100 => 0034")]),a._v(" "),s("li",[a._v("按位或 |："),s("br"),a._v("\n对整型操作数逐位执行布尔或操作，如果其中一个操作数相应的位为 1，或者两个操作数都为 1，那么结果中的这一位就为 1。")]),a._v(" "),s("li",[a._v("按位异或 ^："),s("br"),a._v("\n对整型操作数执行布尔异或操作，异或是指第一个操作数为 true（1/0）或第二个操作数为 true（0/1），但不能同时为 true（1/1）。")]),a._v(" "),s("li",[a._v("按位非 ~："),s("br"),a._v("\n是一元运算符，位于一个整型参数之前，他将操作数的所有位取反。根据Javascript 中带符号的整数的表示方法，对一个值使用“~”运算符相当于改变他的符号为并减 1。")]),a._v(" "),s("li",[a._v("左移 <<："),s("br"),a._v("\n将第一个操作数的所有二进制位进行左移操作，移动的位数有第二个操作数指定，移动的位数是0-31之间的一个整数，新的一位用 0 补充。eg：\n7<<2=28。"),s("br"),a._v("\n7 => 0000 0111"),s("br"),a._v("\n2 => 0001 1100 = 28"),s("br"),a._v("\n快速算法：将一个值左移 1 位，相当于它乘以2，左移两位相当于乘以 4，以此类推。")]),a._v(" "),s("li",[a._v("带符号右移 >>：\n将第一个操作数的所有位进行右移操作，移动的位数由第二个操作数指定，移动的位数是0～31之间的一个整数。右移溢出的位数将忽略。填补在左边的位有原操作数的符号决定。符号位由第一位操作数决定。eg：\n7>>1=3；-7>>1=-4\n7  => 0000 0000 0000 0000 0000 0000 0000 0111"),s("br"),a._v("\n1  => 0000 0000 0000 0000 0000 0000 0000 0011 = 3"),s("br"),a._v("\n-7 => 1000 0000 0000 0000 0000 0000 0000 0111"),s("br"),a._v("\n1  => 1000 0000 0000 0000 0000 0000 0000 0011 = -4"),s("br"),a._v("\n快速算法：将一个值右移 1 位，相当于它除以2，左移两位相当于除以 4，以此类推。")]),a._v(" "),s("li",[a._v("无符号右移 >>>：\n与"),s("code",[a._v(">>")]),a._v("一样，只是左边的高位总是填补 0，做原来的操作符号无关。eg：-1>>4=-1; -1>>>4=0x0FFFFFFF")])]),a._v(" "),s("h3",{attrs:{id:"_4-9-1-相等和不等运算符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-9-1-相等和不等运算符"}},[a._v("#")]),a._v(" 4.9.1 相等和不等运算符")]),a._v(" "),s("p",[a._v("严格相等运算符 "),s("code",[a._v("===")])]),a._v(" "),s("ul",[s("li",[a._v("如果其中一个值是 NaN，或者两个值都是 NaN，则它们不想等，NaN 和其他任何值都是不相等的，包括其本身。通过 x!==x 这个表达式来判断 x 是否为 NaN，只有 x 为 NaN 的时候，这个表达式才为 true。")])]),a._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" b "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("NaN")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\na "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("!==")]),a._v(" a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("             "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// => false")]),a._v("\nb "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("!==")]),a._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("             "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// => true")]),a._v("\n")])])]),s("ul",[s("li",[a._v("如果两个值为字符串，且所含的对应位上的 16 位数完全相等，则它们相等。"),s("em",[a._v("特例")]),a._v("：存在两个字符串含义可能完全一样且所显示出的字符也一样，但具有不同编码的 16 位值，这样的情况，通过"),s("code",[a._v("==")]),a._v("或"),s("code",[a._v("===")]),a._v("的比较结果，都是不相等的。Javascript 并不对 Unicode 进行标准化的转换。")])]),a._v(" "),s("p",[a._v("相等运算符"),s("code",[a._v("==")])]),a._v(" "),s("ul",[s("li",[a._v("null == undefined       // => true")]),a._v(" "),s("li",[a._v("如果一个是数字，一个是字符串，那么会先将字符串转换为数字，然后使用转换后的值进行比较。")]),a._v(" "),s("li",[a._v("如果一个为 true，则会转换为 1 再进行比较，如果一个位 false，则会转换为 0 进行比较。")]),a._v(" "),s("li",[a._v("如果一个为对象，另外一个为数字或字符串，则会存在对应的规则，3.8.3 中提到的，进行转换成原始值。")])]),a._v(" "),s("h3",{attrs:{id:"_4-9-2-比较运算符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-9-2-比较运算符"}},[a._v("#")]),a._v(" 4.9.2 比较运算符")]),a._v(" "),s("p",[s("code",[a._v(">")]),a._v("、"),s("code",[a._v("<")]),a._v("、"),s("code",[a._v("<=")]),a._v("、"),s("code",[a._v(">=")])]),a._v(" "),s("blockquote",[s("p",[a._v("用来检测两个操作数的大小关系，包括数值大小和字母表的顺序。")])]),a._v(" "),s("ul",[s("li",[a._v("字符串是一个由 16 位整数值组成的序列，字符串的比较也只是两个字符串中的字符的数值的比较，由 Unicode 定义的字符编码顺序和任何特定语言或者本地语言字符集中的传统字符编码顺序不尽相同。在 Unicode 中，所有大写的 ASCII 字母都小于小写的字母。")]),a._v(" "),s("li",[a._v("比较运算符的行为，更偏爱数字，如果其中一个是字符串，一个是数字，那么字符串会转换为数字，再进行数字的比较。只有两个都是字符串的时候，才会进行字符串的比较。"),s("em",[a._v("（ps：加号运算符更加偏爱字符串，其中如果有一个是字符串的话，就会进行字符串的连接。）")])]),a._v(" "),s("li",[s("code",[a._v("<=")]),a._v("、"),s("code",[a._v(">=")]),a._v(" 在判断相等的时候，并不依赖相等运算符或严格相等运算符的规则。相反，小于等于只是简单的“不大于”，大于等于只是简单的“不小于”。")]),a._v(" "),s("li",[a._v("其中一个操作数，或者是转换后是 NaN 的时候，比较运算符的结果都是 false。")])]),a._v(" "),s("h3",{attrs:{id:"_4-9-4-instanceof-运算符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-9-4-instanceof-运算符"}},[a._v("#")]),a._v(" 4.9.4 instanceof 运算符")]),a._v(" "),s("p",[a._v("工作原理来源于“原型链”（prototypr chain）")]),a._v(" "),s("h3",{attrs:{id:"_4-12-表达式计算"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-12-表达式计算"}},[a._v("#")]),a._v(" 4.12 表达式计算")]),a._v(" "),s("p",[a._v("eval 是一个全局函数，也是一个运算符。尽量少用，不用。")]),a._v(" "),s("h3",{attrs:{id:"_4-12-1-eval"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-12-1-eval"}},[a._v("#")]),a._v(" 4.12.1 eval()")]),a._v(" "),s("p",[a._v("eval() 只有一个参数，参数类型为字符串。他的词法环境，是在调用它的那一层，如果是在函数内部，那么他查找或定义的新变量，都是在函数内部。如果是在最顶层代码，则会作用于全局变量和全局函数。"),s("br"),a._v("\n传入的参数，须是一个有逻辑，有语义的完成字符串，如果传入其他类型，则会原封不动返回该参数，若逻辑语义有误，则会报错。")]),a._v(" "),s("h3",{attrs:{id:"_4-12-2-全局-eval"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-12-2-全局-eval"}},[a._v("#")]),a._v(" 4.12.2 全局 eval()")]),a._v(" "),s("p",[a._v("eval() 具有更改局部变量的能力。他有两种调用方式，直接调用 eval()（直接的eval），另外一种，通过别名调用，eg：var g = eval(); g()。"),s("br"),a._v("\n通过别名调用"),s("code",[a._v("g()")]),a._v("的时候，他的上下文作用域是全局对象，而通过"),s("code",[a._v("eval()")]),a._v("自身调用时，则是在调用的上下文作用域。"),s("br"),a._v("\n在 ES5 中，别名调用，使用全局对象作为其上下文作用域，但无法进行读、写、定义局部变量和函数。")]),a._v(" "),s("h3",{attrs:{id:"_4-12-3-严格-eval"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-12-3-严格-eval"}},[a._v("#")]),a._v(" 4.12.3 严格 eval()")]),a._v(" "),s("p",[a._v("在严格模式下， eval() 是私有上下文环境的局部 eval，可以查询更改局部变量，但不能在局部作用域定义新的变量或函数。"),s("br"),a._v("\n严格模式下，eval 不能被取别名。被列为保留字。")]),a._v(" "),s("h3",{attrs:{id:"_4-13-3-delete-运算符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-13-3-delete-运算符"}},[a._v("#")]),a._v(" 4.13.3 delete 运算符")]),a._v(" "),s("blockquote",[s("p",[a._v("用来删除对象上的属性，或者数组元素。")])]),a._v(" "),s("ul",[s("li",[a._v("对象删除属性后，访问该属性，返回的是 undefined。")]),a._v(" "),s("li",[a._v("数组删除元素后，访问该位置的元素，返回的是 undefined，但是数组长度不变。")]),a._v(" "),s("li",[a._v("不能 delete 一些内置核心和客户端属性，还有通过 var、function 声明的。")]),a._v(" "),s("li",[a._v("严格模式下，delete 的操作数如果是合法的，那么将会返回 true，如果不合法，比如变量、函数或函数参数，将会抛出一个语法错误（SyntacError）异常；如果删除不可配置的属性，会抛出类型错误。")]),a._v(" "),s("li",[a._v("非严格模式下，上述都不会报错，只会返回个 false。")])])])}),[],!1,null,null,null);t.default=e.exports}}]);